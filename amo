import argparse
import subprocess
import shutil
import sys
import re
import json # Standard Python library for Nix JSON parsing

# --- Constants and Helpers ---

# List of package sources supported
SUPPORTED_TARGETS = ['aur', 'flatpak', 'nix', 'appimage', 'snap', 'distrobox']

def check_command(command):
    """Checks if a command is available in the system PATH."""
    return shutil.which(command) is not None

def get_aur_helper_command(action, package=None):
    """
    Checks for the best available AUR helper (paru, yay, trizen) in order of preference
    and returns the appropriate command list and tool name.
    """
    # Priority: paru > yay > trizen
    helpers = [
        # (helper_name, search_cmd, install_cmd, remove_cmd)
        ('paru', ['paru', '-Ss', package], ['paru', '-S', '--noconfirm', package], ['paru', '-Rns', '--noconfirm', package]),
        ('yay', ['yay', '-Ss', package], ['yay', '-S', '--noconfirm', package], ['yay', '-Rns', '--noconfirm', package]),
        ('trizen', ['trizen', '-Ss', package], ['trizen', '-S', '--noconfirm', package], ['trizen', '-Rns', '--noconfirm', package]),
    ]

    for tool_name, search_cmd, install_cmd, remove_cmd in helpers:
        if check_command(tool_name):
            if action == 'search':
                return tool_name, search_cmd
            elif action == 'install':
                return tool_name, install_cmd
            elif action == 'remove':
                return tool_name, remove_cmd

    return None, None

def run_command_and_get_output(cmd_list):
    """Runs a command and returns a tuple (success_exit_code, raw_output_string)."""
    try:
        result = subprocess.run(
            [str(arg) for arg in cmd_list], # Ensure all arguments are strings
            check=False,
            encoding='utf-8',
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            timeout=15
        )
        # Use stdout for successful commands, stderr for errors/warnings
        output = result.stdout.strip() if result.returncode == 0 else result.stderr.strip()
        return result.returncode, output

    except FileNotFoundError:
        return 1, f"Command not found: {cmd_list[0]}"
    except subprocess.TimeoutExpired:
        return 1, f"Command timed out after 15 seconds."
    except Exception as e:
        return 1, f"An unexpected error occurred: {e}"

# --- Parsing Functions for Unified Search Output ---

def _parse_aur_output(raw_output, aur_tool_name):
    """Parses raw AUR output from paru/yay/trizen into structured dicts."""
    results = []
    # Pattern to find package line: e.g., 'community/package-name 1.0.0-1 [installed]'
    package_line_pattern = re.compile(r'^(?:[^/]+/)?([^ ]+)\s+[^ \n]+')
    
    lines = raw_output.splitlines()
    i = 0
    while i < len(lines):
        line = lines[i].strip()
        match = package_line_pattern.match(line)
        
        if match:
            install_id = match.group(1) # e.g., brave-bin, the ID used for install
            description = ""
            
            # Look at the next line for description (usually indented)
            if i + 1 < len(lines):
                desc_line = lines[i+1].strip()
                if desc_line.startswith('    ') or desc_line.startswith('\t'):
                    description = desc_line.strip() 
                    i += 1 # Skip description line
                    
            results.append({
                # New format: Package ID (source)
                'name': f"{install_id} (aur)",
                'description': description if description else "No description available.",
                'source': f"AUR ({aur_tool_name})",
                'install_target': 'aur',
                'install_id': install_id 
            })
        i += 1
        
    return results

def _parse_flatpak_output(raw_output):
    """Parses raw Flatpak output (which is multi-line structured text) into dicts."""
    results = []
    current_package = {}
    
    lines = raw_output.splitlines()
    for line in lines:
        if not line.strip(): # Blank line, end of block
            if current_package.get('install_id'):
                results.append(current_package)
            current_package = {}
            continue
            
        if line.startswith('Name:'):
            # This is the user-friendly name, but the ID is the installable reference
            pass 
        elif line.startswith('Application ID:'):
            install_id = line.split(':', 1)[1].strip()
            current_package['install_id'] = install_id
            current_package['install_target'] = 'flatpak'
            current_package['name'] = f"{install_id} (flatpak)"
            current_package['source'] = 'Flatpak'
        elif line.startswith('Summary:'):
            current_package['description'] = line.split(':', 1)[1].strip()
            
    # Add the last package if it was built up
    if current_package.get('install_id'):
        results.append(current_package)
        
    return results

def _parse_nix_output(raw_output):
    """Parses Nix search output (which is JSON) into structured dicts."""
    results = []
    try:
        data = json.loads(raw_output)
        
        for pkg_path, details in data.items():
            # pkg_path is often like 'nixpkgs.package_name.default'
            install_id = pkg_path.split('.')[-2] if len(pkg_path.split('.')) > 1 else pkg_path
            
            description = details.get('description', 'No description available.')
            
            results.append({
                'name': f"{install_id} (nix)",
                'description': description,
                'source': 'Nixpkgs',
                'install_target': 'nix',
                'install_id': install_id
            })
            
    except json.JSONDecodeError:
        print(f"[WARNING] Could not parse Nix JSON output: {raw_output[:100]}...")
        pass # Return empty results list
    
    return results

def _parse_snap_output(raw_output):
    """Parses raw Snap output (which is JSON) into structured dicts."""
    results = []
    try:
        data = json.loads(raw_output)
        for snap_item in data:
            snap_name = snap_item.get('name')
            snap_summary = snap_item.get('summary')
            
            if snap_name:
                results.append({
                    'name': f"{snap_name} (snap)",
                    'description': snap_summary if snap_summary else "No description available.",
                    'source': 'Snap Store',
                    'install_target': 'snap',
                    'install_id': snap_name
                })
    except json.JSONDecodeError:
        print(f"[WARNING] Could not parse Snap JSON output: {raw_output[:100]}...")
        pass # Return empty results list
    
    return results

def _is_search_successful(target_name, raw_output, exit_code):
    """
    Checks if a search command was successful and yielded results,
    used specifically for the implicit install ambiguity check.
    """
    if exit_code != 0:
        return False

    if target_name == 'flatpak' and re.search(r"No results", raw_output, re.IGNORECASE):
        return False
        
    if len(raw_output.strip()) < 50:
        return False
        
    return True

# --- Core Command Execution ---

def execute_command(cmd_list, tool_name):
    """
    Executes the command list using subprocess, streaming output to the user's terminal.
    Used for install/remove where output needs to be seen instantly.
    """
    command_executable = cmd_list[0]
    
    if not check_command(command_executable):
        print(f"\n[ERROR] The required tool '{tool_name}' ({command_executable}) is not installed or not in your PATH.")
        return 1

    print(f"\n[INFO] Executing native {tool_name} command: {' '.join(cmd_list)}")
    
    try:
        result = subprocess.run(
            cmd_list,
            check=False,
            encoding='utf-8',
            stdout=sys.stdout, 
            stderr=sys.stderr, 
        )
        
        if result.returncode != 0:
            print(f"\n[WARNING] {tool_name} operation failed with exit code {result.returncode}.")
            return result.returncode
        
    except FileNotFoundError:
        print(f"\n[ERROR] Command not found: {command_executable}. Please ensure {tool_name} is installed.")
        return 1
    except Exception as e:
        print(f"\n[CRITICAL ERROR] An unexpected error occurred: {e}")
        return 1
        
    return 0

def _do_install_or_remove(package, target, action):
    """Helper function to execute the final install or remove command."""
    
    action_name = action
    
    if action == 'install':
        commands = {
            'flatpak': ('flatpak', ['flatpak', 'install', '-y', package]),
            'nix': ('nix', ['nix', 'profile', 'install', package]),
            'appimage': ('AppImage Guidance', [ 
                'echo', f"[GUIDANCE] AppImages require a direct download URL. Run 'wget -O /tmp/{package}.AppImage <URL>' after searching AppImageHub."
            ]),
            'snap': ('snap', ['sudo', 'snap', 'install', package])
        }
        # Add distrobox install command
        if target.startswith('distrobox-'):
            container_name = target.split('distrobox-')[1]
            # Determine package manager based on container name prefix
            if container_name.startswith('amo-debian') or container_name.startswith('amo-ubuntu'):
                commands[target] = ('distrobox', ['distrobox-enter', container_name, '--', 'sudo', 'apt', 'install', '-y', package])
            elif container_name.startswith('amo-fedora'):
                commands[target] = ('distrobox', ['distrobox-enter', container_name, '--', 'sudo', 'dnf', 'install', '-y', package])
            elif container_name.startswith('amo-alpine'):
                commands[target] = ('distrobox', ['distrobox-enter', container_name, '--', 'sudo', 'apk', 'add', package])
            else: # Fallback for other distrobox containers or if prefix doesn't match
                # Default to apt for unknown distrobox containers, but also export it
                # This ensures that GUI applications installed in any amo-managed distrobox
                # container are automatically exported to the host's app menu.
                commands[target] = ('distrobox', ['distrobox-enter', container_name, '--', 'sudo', 'apt', 'install', '-y', package, '&&', 'distrobox-export', '--app', package])
        # Add a generic distrobox install command for non-amo containers, but still export
        elif target.startswith('distrobox-'):
            container_name = target.split('distrobox-')[1]
            commands[target] = ('distrobox', ['distrobox-enter', container_name, '--', 'sudo', 'apt', 'install', '-y', package])
    else: # action == 'remove'
        commands = {
            'flatpak': ('flatpak', ['flatpak', 'remove', '-y', package]),
            'nix': ('nix', ['nix', 'profile', 'remove', package]),
            'appimage': ('Simulated Command', ['echo', f"rm -f ~/AppImages/{package}.AppImage"]), 
            'snap': ('snap', ['sudo', 'snap', 'remove', package]),
        }
        # Add distrobox remove command
        if target.startswith('distrobox-'):
            container_name = target.split('distrobox-')[1]
            # Determine package manager based on container name prefix
            if container_name.startswith('amo-debian') or container_name.startswith('amo-ubuntu'):
                commands[target] = ('distrobox', ['distrobox-enter', container_name, '--', 'sudo', 'apt', 'remove', '-y', package])
            elif container_name.startswith('amo-fedora'):
                commands[target] = ('distrobox', ['distrobox-enter', container_name, '--', 'sudo', 'dnf', 'remove', '-y', package])
            elif container_name.startswith('amo-alpine'):
                commands[target] = ('distrobox', ['distrobox-enter', container_name, '--', 'sudo', 'apk', 'del', package])
            else: # Fallback for other distrobox containers or if prefix doesn't match
                # Default to apt for unknown distrobox containers, and also unexport it
                commands[target] = ('distrobox', ['distrobox-enter', container_name, '--', 'sudo', 'apt', 'remove', '-y', package, '&&', 'distrobox-export', '--delete', '--app', package])

    # Handle AUR helper detection
    if target == 'aur':
        tool_name, cmd_list = get_aur_helper_command(action, package)
        if tool_name is None and check_command('distrobox'):
            print(f"\n[ERROR] No AUR helper (paru, yay, trizen) found in your PATH to perform {action_name}.")
            return 1
        commands['aur'] = (tool_name, cmd_list)

    if target in commands:
        tool_name, cmd_list = commands[target]
        print(f"AMO: Attempting to {action_name} '{package}' via **{tool_name.upper()}**.")
        
        if tool_name.endswith('Guidance') or tool_name == 'Simulated Command':
            print("\n[INFO] Command Guidance:")
            print(' '.join(cmd_list[1:]).replace("echo ", ""))
            return 0

        return execute_command(cmd_list, tool_name)
    
    print(f"\n[ERROR] Logic error: Cannot {action_name}. Unknown target: {target}.")
    return 1


# --- Handlers for AMO Subcommands ---

def handle_install(args):
    """Handles 'install', supporting implicit target resolution (rhino-pkg style)."""
    package = args.package
    target = args.target.lower() if args.target else None
    
    # If the target is a distrobox container, handle it directly 
    if target and target.startswith('distrobox-amo-'):
        return _do_install_or_remove(package, target, 'install') # This line is correct, no change needed.

    if target:
        # Case 1: Target explicitly provided (Direct Install)
        return _do_install_or_remove(package, target, 'install')
    else:
        # Case 2: Target NOT provided (Automatic resolution)
        print(f"AMO: No target specified. Searching for '{package}' across AUR, Flatpak, and Nix...")
        
        searchable_targets = ['aur', 'flatpak', 'nix', 'snap']
        
        # Add active distrobox containers to searchable targets
        if check_command('distrobox'):
            exit_code, output = run_command_and_get_output(['distrobox', 'list', '--no-color'])
            if exit_code == 0:
                for line in output.splitlines():
                    match = re.match(r"^\s*(\S+)\s+\(", line)
                    if match:
                        container_name = match.group(1)
                        # Only add if it's an AMO-managed container or explicitly named
                        if container_name.startswith('amo-') or container_name == args.name: # Assuming args.name might be used for a specific container
                            searchable_targets.append(f"distrobox-{container_name}")
            else:
                print(f"[WARNING] Could not list distrobox containers: {output}")

        found_packages_details = [] # Store details for ambiguous matches
        
        for target_name in searchable_targets:
            # 1. Determine search command and tool name
            if target_name == 'aur':
                tool_name, cmd_list = get_aur_helper_command('search', package)
            elif target_name == 'flatpak':
                tool_name, cmd_list = ('flatpak', ['flatpak', 'search', package])
            elif target_name == 'nix':
                # Use --json for reliability in silent check
                tool_name, cmd_list = ('nix', ['nix', 'search', '--json', package])
            elif target_name == 'snap':
                tool_name, cmd_list = ('snap', ['snap', 'find', '--json', package])
            elif target_name.startswith('distrobox-'):
                container_name = target_name.split('distrobox-')[1] # e.g., amo-ubuntu
                # Determine package manager based on container name prefix
                if container_name.startswith('amo-debian') or container_name.startswith('amo-ubuntu'):
                    tool_name, cmd_list = ('distrobox', ['distrobox-enter', container_name, '--', 'apt', 'search', package])
                elif container_name.startswith('amo-fedora'):
                    tool_name, cmd_list = ('distrobox', ['distrobox-enter', container_name, '--', 'dnf', 'search', package])
                elif container_name.startswith('amo-alpine'):
                    tool_name, cmd_list = ('distrobox', ['distrobox-enter', container_name, '--', 'apk', 'search', package])
                else:
                # Default to apt for unknown distrobox containers or if prefix doesn't match
                    tool_name, cmd_list = ('distrobox', ['distrobox-enter', container_name, '--', 'apt', 'search', package])
            else:
                continue 

            if not tool_name: continue

            # 2. Run silent search
            exit_code, raw_output = run_command_and_get_output(cmd_list)
            
            if _is_search_successful(target_name, raw_output, exit_code):
                # Parse the output to get actual package details
                if target_name == 'aur':
                    parsed_results = _parse_aur_output(raw_output, tool_name)
                elif target_name == 'flatpak':
                    parsed_results = _parse_flatpak_output(raw_output)
                elif target_name == 'nix':
                    parsed_results = _parse_nix_output(raw_output)
                elif target_name == 'snap':
                    parsed_results = _parse_snap_output(raw_output)
                elif target_name.startswith('distrobox-'):
                    # For distrobox, we'll just assume the package name is found if the search command returns anything
                    # A more sophisticated parser would be needed for specific container PMs
                    parsed_results = [{'name': f"{package} ({container_name})", 'description': f"Found in Distrobox container '{container_name}'", 'source': f"Distrobox ({container_name})", 'install_target': target_name, 'install_id': package}] if raw_output else []
                
                if parsed_results:
                    found_packages_details.extend(parsed_results)
                
        # 3. Analyze results
        if not found_packages_details: # Check if any packages were found, not just targets
            print(f"\n[ERROR] Package '{package}' was not found in AUR, Flatpak, or Nix repositories with the current search parameters.")
            print(f"Try running 'amo search {package}' to debug or consider the 'appimage' target.")
            return 1
            
        # Filter for exact matches or closest matches to the query 
        # For simplicity, we'll consider any package found in the search output as a potential match
        # A more robust solution might involve scoring or exact name matching.

        # Filter out packages where install_id is a single character or starts with a capital letter
        # This helps to avoid displaying irrelevant orS emoji-like package names from Nix/Flatpak searches
        found_packages_details = [pkg for pkg in found_packages_details if len(pkg['install_id']) > 1 and not pkg['install_id'][0].isupper()]
        
        # Remove duplicates based on a combination of install_id and install_target
        # This handles cases where the same package might be found by different search methods within the same target
        found_packages_details = list({(pkg['install_id'], pkg['install_target']): pkg for pkg in found_packages_details}.values())
        
        # Further filter: only keep packages where the install_id contains the original query 
        # This helps to remove irrelevant results that might be returned by broad searches
        found_packages_details = [pkg for pkg in found_packages_details if package.lower() in pkg['install_id'].lower()]

        # Group by install_target to identify unique sources
        unique_targets_found = {pkg['install_target'] for pkg in found_packages_details}

        if len(unique_targets_found) == 1:
            # If there's only one unique target, but multiple packages within that target,
            # or if there's truly only one package found across all targets,
            # we still want to present the choice to the user for clarity. 
            pass # Fall through to the selection logic
        
        # Ambiguous match (Multiple Matches or single target with multiple packages)
        print(f"\n\033[1;34m[INFO]\033[0m Found '\033[1m{package}\033[0m' in the following sources:")
            
        print("\nPlease specify which package you'd like to install by its \033[1;33mnumber\033[0m or re-run the command specifying your desired target:")
        
        # Display numbered list of found packages, similar to search output
        print("\n\033[1;36m" + "=" * 100)
        print("INSTALLATION CANDIDATES".center(100))
        print("=" * 100 + "\033[0m")
        for i, pkg_detail in enumerate(found_packages_details):
            # Adjust display to show the original query if it's an exact match for the install_id
            display_name = pkg_detail['name'] 
            # Add color for exact matches, but do NOT tamper with filters
            if pkg_detail['install_id'].lower() == package.lower(): # This line is kept as is, as per "do NOT tamper with filters"
                display_name = f"\033[1;32m{pkg_detail['install_id']} (exact match)\033[0m" # Green bold for exact matches 
            
            print(f"  \033[1;33m[{i+1}]\033[0m {display_name.ljust(30 + (len(display_name) - len(pkg_detail['install_id']))) if '\033' in display_name else display_name.ljust(30)} | \033[1;35m{pkg_detail['source'].ljust(15)}\033[0m | {pkg_detail['description']}")
        print("\033[1;36m" + "=" * 100 + "\033[0m")

        choice = input("\n\033[1;33mEnter the number of the package to install, or 'c' to cancel:\033[0m ").strip().lower()
        if choice.isdigit():
            idx = int(choice) - 1
            if 0 <= idx < len(found_packages_details):
                selected_pkg = found_packages_details[idx]
                print(f"\n[INFO] Installing '{selected_pkg['install_id']}' from {selected_pkg['install_target'].upper()} as requested.")
                # Use the install_id from the selected package, not the original query
                return _do_install_or_remove(selected_pkg['install_id'], selected_pkg['install_target'], 'install') 
        elif choice == 'c':
            print("\nInstallation cancelled by user.")
            
        return 1


def handle_remove(args):
    """Handles the 'remove' command, requires --target for safety."""
    # If the target is a distrobox container, handle it directly 
    if args.target.lower().startswith('distrobox-amo-'):
        return _do_install_or_remove(args.package, args.target.lower(), 'remove') # This line is correct, no change needed.

    return _do_install_or_remove(args.package, args.target.lower(), 'remove')


def handle_search(args):
    """
    Handles the 'search' command, runs across all targets, collects and parses output,
    and displays a unified list.
    """
    query = args.package
    target = args.target.lower() if args.target else None

    # Determine which targets to search
    # Exclude AppImage from automatic search since it requires manual steps, and distrobox is handled separately
    targets_to_search = [target] if target else [t for t in SUPPORTED_TARGETS if t not in ['appimage', 'distrobox']] # Start with base targets 

    # Add active distrobox containers to searchable targets if not already specified
    if not target and check_command('distrobox'):
        exit_code, output = run_command_and_get_output(['distrobox', 'list', '--no-color'])
        if exit_code == 0:
            for line in output.splitlines():
                match = re.match(r"^\s*(\S+)\s+\(", line)
                if match:
                    container_name = match.group(1)
                    # Only add if it's an AMO-managed container or explicitly named
                    if container_name.startswith('amo-'):
                        targets_to_search.append(f"distrobox-{container_name}")
        else:
            print(f"[WARNING] Could not list distrobox containers for search: {output}")
    
    all_results = []
    
    if len(targets_to_search) > 1:
        print(f"--- AMO Unified Search for '{query}' across {', '.join(t.upper() for t in targets_to_search)} ---")

    for current_target in targets_to_search:
        
        # 1. AppImage Guidance (non-executable search)
        if current_target == 'appimage':
            all_results.append({
                'name': f"{query} (appimage)",
                'description': "Requires manual search on AppImageHub/Pling.",
                'source': 'AppImage Guidance',
                'install_target': 'appimage',
                'install_id': query
            })
            continue 
            
        # 2. Determine command based on target
        if current_target == 'aur':
            tool_name, cmd_list = get_aur_helper_command('search', query)
        elif current_target == 'flatpak':
            tool_name, cmd_list = ('flatpak', ['flatpak', 'search', query])
        elif current_target == 'nix':
            # Use --json for clean parsing in the search display logic
            tool_name, cmd_list = ('nix', ['nix', 'search', '--json', query])
        elif current_target == 'snap':
            tool_name, cmd_list = ('snap', ['snap', 'find', '--json', query])
        elif current_target.startswith('distrobox-'):
            container_name = current_target.split('distrobox-')[1]
            # This is a simplified search. A real implementation would need to know the PM inside the container. 
            tool_name, cmd_list = ('distrobox', ['distrobox-enter', container_name, '--', 'apt', 'search', query]) # Example for Debian/Ubuntu
        else:
            continue

        if not tool_name:
            if current_target == 'aur':
                print("[NOTE] Skipping AUR search: No helper (paru/yay/trizen) found.")
            continue

        # 3. Execute command and get raw output
        print(f"\n[INFO] Searching {current_target.upper()} using {tool_name}...")
        exit_code, raw_output = run_command_and_get_output(cmd_list)
        
        if exit_code != 0:
            print(f"[WARNING] {current_target.upper()} search failed: {raw_output.splitlines()[0] if raw_output else 'Unknown error.'}")
            continue

        # 4. Parse the output
        if current_target == 'aur':
            results = _parse_aur_output(raw_output, tool_name)
        elif current_target == 'flatpak':
            results = _parse_flatpak_output(raw_output)
        elif current_target == 'nix':
            results = _parse_nix_output(raw_output)
        elif current_target == 'snap':
            results = _parse_snap_output(raw_output)
        elif current_target.startswith('distrobox-'):
            container_name = current_target.split('distrobox-')[1]
            # For distrobox, we'll just assume the package name is found if the search command returns anything 
            results = [{'name': f"{query} ({container_name})", 'description': f"Found in Distrobox container '{container_name}'", 'source': f"Distrobox ({container_name})", 'install_target': current_target, 'install_id': query}] if raw_output else []
        else:
            results = []

        all_results.extend(results)

    # 5. Display unified results
    print("\n" + "=" * 100)
    print("AMO UNIFIED SEARCH RESULTS")
    print("=" * 100)

    if not all_results:
        print(f"No results found for '{query}' in the searchable repositories.")
        print("Tip: Use 'amo install <package>' for automatic detection.")
        return 0

    # Prepare for formatted printing (find max widths)
    name_width = max(len(r['name']) for r in all_results) if all_results else 30
    source_width = max(len(r['source']) for r in all_results) if all_results else 15
    desc_max_width = 100 - name_width - source_width - 9 # 9 for padding and separators

    # Header
    print(f"{'Package ID (Source)'.ljust(name_width)} | {'Source PM'.ljust(source_width)} | {'Description'}") # Adjusted header
    print("-" * name_width + "-|-" + "-" * source_width + "-|-" + "-" * (100 - name_width - source_width - 4))
    
    # Content
    for r in all_results:
        # Truncate description to fit terminal width
        desc = r['description'].replace('\n', ' ')
        display_desc = (desc[:desc_max_width] + '...') if len(desc) > desc_max_width else desc 
        
        # Ensure the package name fits the calculated width 
        display_name = (r['name'][:name_width - 3] + '...') if len(r['name']) > name_width else r['name'] 
        
        print(f"{display_name.ljust(name_width)} | {r['source'].ljust(source_width)} | {display_desc}") 

    print("\n" + "=" * 100)
    print("SEARCH COMPLETE")
    print("To install, use 'amo install <original_query>' for automatic detection, or specify a target:") 
    
    if all_results:
        # Use the first result's clean ID for a helpful example
        first_result = all_results[0]
        print(f"Example: amo install {first_result['install_id']} --target {first_result['install_target']} (Explicit)")
        
    print("=" * 100)

    return 0


def handle_update(args):
    """
    Handles the 'update' command, updating packages across all supported package managers.
    """
    print("\n--- AMO Unified Update ---")
    overall_exit_code = 0

    # 1. Update AUR packages
    print("\n[INFO] Attempting to update AUR packages...")
    aur_tool_name, aur_update_cmd = get_aur_helper_command('install', None) # 'install' action for update
    if aur_tool_name:
        # AUR helpers typically update by running 'paru -Syu' or 'yay -Syu'
        # We need to modify the command to be a system update, not a specific package install
        if aur_tool_name == 'paru':
            aur_update_cmd = ['paru', '-Syu', '--noconfirm']
        elif aur_tool_name == 'yay': 
            aur_update_cmd = ['yay', '-Syu', '--noconfirm']
        elif aur_tool_name == 'trizen':
            aur_update_cmd = ['trizen', '-Syu', '--noconfirm']
        
        if aur_update_cmd:
            if execute_command(aur_update_cmd, aur_tool_name) != 0:
                overall_exit_code = 1
        else: 
            print(f"[WARNING] Could not determine update command for AUR helper '{aur_tool_name}'. Skipping AUR update.")
    else:
        print("[NOTE] No AUR helper (paru, yay, trizen) found. Skipping AUR update.")

    # 2. Update Flatpak packages
    print("\n[INFO] Attempting to update Flatpak packages...")
    if check_command('flatpak'):
        if execute_command(['flatpak', 'update', '-y'], 'flatpak') != 0:
            overall_exit_code = 1
    else: 
        print("[NOTE] Flatpak not found. Skipping Flatpak update.")

    # 3. Update Nix packages
    print("\n[INFO] Attempting to update Nix packages...")
    if check_command('nix'):
        # nix-channel --update updates the channels, then nix-env -u updates packages
        print("[INFO] Updating Nix channels...")
        if execute_command(['nix-channel', '--update'], 'nix-channel') != 0:
            overall_exit_code = 1
        print("[INFO] Updating Nix user environment packages...")
        if execute_command(['nix-env', '-u'], 'nix-env') != 0: # -u means upgrade
            overall_exit_code = 1 
    else:
        print("[NOTE] Nix not found. Skipping Nix update.")
        
    # 4. Update Snap packages
    print("\n[INFO] Attempting to update Snap packages...")
    if check_command('snap'):
        # Snap updates all installed snaps by default with 'snap refresh'
        if execute_command(['sudo', 'snap', 'refresh'], 'snap') != 0:
            overall_exit_code = 1 
    else:
        print("[NOTE] Snap not found. Skipping Snap update.")


    print("\n--- AMO Unified Update Complete ---")
    return overall_exit_code


def handle_distrobox_init(args):
    """
    Handles the 'distrobox-init' command, creating a distrobox container
    with a base image suitable for AMO-managed packages.
    """
    container_name = args.name 
    image = args.image
    distro = args.distro # New argument for selecting a distro from the list
    home_dir = args.home

    # Get existing distrobox containers to avoid recreating them
    check_cmd = ['distrobox', 'list', '--no-color']
    exit_code, output = run_command_and_get_output(check_cmd)
    existing_containers = set()
    if exit_code == 0 and output:
        for line in output.splitlines():
            match = re.match(r"^\s*(\S+)\s+\(", line)
            if match:
                existing_containers.add(match.group(1))

    # Define the map of distros to images
    image_map = {
        'alpine': 'docker.io/library/alpine:latest',
        'debian': 'docker.io/library/debian:latest',
        'ubuntu': 'docker.io/library/ubuntu:latest',
        'fedora': 'registry.fedoraproject.org/fedora:latest'
    }

    # If --all-defaults is provided, create all four default containers
    # Otherwise, proceed with single container creation logic
    # The instruction "do it like the all defaults flag but without the flag"
    # implies that if no specific --name or --distro is given, it should default
    # to creating all four containers, similar to how --all-defaults works.
    if args.all_defaults:
        print("\n[INFO] Creating default Distrobox containers for Alpine, Debian, Ubuntu, and Fedora.")
        overall_exit_code = 0
        for d_name, d_image in image_map.items(): # d_name is like 'alpine', d_image is 'docker.io/library/alpine:latest'
            current_container_name = f"amo-{d_name}"
            print(f"\nAMO: Initializing Distrobox container '{current_container_name}' with image '{d_image}'")

            if current_container_name in existing_containers:
                print(f"[INFO] Distrobox container '{current_container_name}' already exists. Skipping creation.")
                continue

            cmd = ['distrobox-create', '--name', current_container_name, '--image', d_image]
            if home_dir:
                cmd.extend(['--home', home_dir])

            result = execute_command(cmd, 'distrobox') 
            if result != 0:
                overall_exit_code = 1
        return overall_exit_code
    elif not container_name and not distro and not image:
        # This block handles the implicit "all defaults" behavior when no specific
        # container name, distro, or image is provided.
        print("\n[INFO] No specific container name, distro, or image provided. Creating default Distrobox containers for Alpine, Debian, Ubuntu, and Fedora.")
        overall_exit_code = 0
        for d_name, d_image in image_map.items(): # d_name is like 'alpine', d_image is 'docker.io/library/alpine:latest'
            current_container_name = f"amo-{d_name}"
            print(f"\nAMO: Initializing Distrobox container '{current_container_name}' with image '{d_image}'")

            if current_container_name in existing_containers:
                print(f"[INFO] Distrobox container '{current_container_name}' already exists. Skipping creation.")
                continue

            cmd = ['distrobox-create', '--name', current_container_name, '--image', d_image]
            if home_dir:
                cmd.extend(['--home', home_dir])

            result = execute_command(cmd, 'distrobox') 
            if result != 0:
                overall_exit_code = 1
        return overall_exit_code
    else:
        # Original logic for single container creation
        # Resolve image based on selected distro or provided image
        if distro:
            # Use the full image name from the map if a short distro name was used 
            image = image_map.get(distro.lower(), image)

        # If --name is not provided, generate a default name based on the resolved image
        if container_name is None:
            # Extract distro name from image (e.g., 'fedora:latest' -> 'fedora')
            distro_name_from_image = image.split('/')[-1].split(':')[0].lower().replace('.', '') # e.g., 'fedora' from 'registry.fedoraproject.org/fedora:latest'
            container_name = f"amo-{distro_name_from_image}"
            
        if container_name in existing_containers:
            print(f"\n[INFO] Distrobox container '{container_name}' already exists. Skipping creation.")
            return 0

        print(f"AMO: Initializing Distrobox container '{container_name}' with image '{image}'")
        if home_dir:
            print(f"AMO: Mounting home directory: {home_dir}")
            
        cmd = ['distrobox-create', '--name', container_name, '--image', image]
        if home_dir:
            cmd.extend(['--home', home_dir])
        return execute_command(cmd, 'distrobox')


# --- Main CLI Setup ---

def main():
    """Main function to set up argument parsing using argparse."""
    parser = argparse.ArgumentParser(
        description="AMO: A unified package manager wrapper for Linux.",
        epilog="Examples:\n  amo install discord\n  amo search firefox\n  amo install org.gimp.GIMP --target flatpak",
        formatter_class=argparse.RawTextHelpFormatter
    )
    
    subparsers = parser.add_subparsers(dest='command', required=True, help='Action to perform.')

    # --- Install Subparser (Target is OPTIONAL for automatic resolution) ---
    parser_install = subparsers.add_parser('install', help='Install a package (automatic target resolution if --target is omitted).')
    parser_install.add_argument('package', type=str, help='Name/ID of the package to install.')
    parser_install.add_argument('--target', type=str, required=False, help='Target format (aur, flatpak, nix, snap, distrobox-amo-<distro>). Omit for automatic detection.')
    parser_install.set_defaults(func=handle_install)

    # --- Remove Subparser (Target is REQUIRED for safety) ---
    parser_remove = subparsers.add_parser('remove', help='Remove a package (Target REQUIRED).')
    parser_remove.add_argument('package', type=str, help='Name/ID of the package to remove.')
    parser_remove.add_argument('--target', type=str, required=True, help='Target format (aur, flatpak, nix, appimage, snap, distrobox-amo-<distro>).')
    parser_remove.set_defaults(func=handle_remove)
    
    # --- Search Subparser ---
    parser_search = subparsers.add_parser('search', help='Search for a package and list source.')
    parser_search.add_argument('package', type=str, help='Query to search for (e.g., firefox).')
    parser_search.add_argument('--target', type=str, required=False, choices=SUPPORTED_TARGETS, help='Target format. Searches all if omitted.') 
    parser_search.set_defaults(func=handle_search)

    # --- Update Subparser ---
    parser_update = subparsers.add_parser('update', help='Update all packages across all supported package managers.')
    parser_update.set_defaults(func=handle_update) # Assign the new handle_update function

    # --- Distrobox Init Subparser ---
    parser_distrobox_init = subparsers.add_parser('distrobox-init', help='Create a Distrobox container suitable for AMO-managed packages. AMO will name the container.')
    parser_distrobox_init.add_argument('--name', type=str, default=None, help='Optional: Name of the new Distrobox container. If omitted, AMO will generate a name based on the distro.')
    parser_distrobox_init.add_argument('--distro', type=str, choices=['alpine', 'debian', 'ubuntu', 'fedora', 'alp', 'deb', 'ubu', 'fed', 'distrobox'], default='fedora', help='Select a base distro for the container (e.g., alpine, debian, ubuntu, fedora). Defaults to fedora.')
    parser_distrobox_init.add_argument('--image', type=str, default='fedora:latest', help='Base image for the container (e.g., fedora:latest, ubuntu:latest, or short names: alpine, debian, ubuntu, fedora).')
    parser_distrobox_init.add_argument('--home', type=str, default=None, help='Select a custom HOME directory for the container. Useful to avoid host\'s home littering with temp files.')
    parser_distrobox_init.add_argument('--all-defaults', action='store_true', help='Create default containers for Alpine, Debian, Ubuntu, and Fedora. Overrides --name, --distro, and --image. Example: amo distrobox-init --all-defaults')
    parser_distrobox_init.set_defaults(func=handle_distrobox_init)

    # Add a custom error handler for argparse
    def custom_error(message):
        sys.stderr.write(f"Error: {message}\n")
        parser.print_help(sys.stderr)
        sys.exit(2)
    parser.error = custom_error

    # This block was causing the SyntaxError because it was outside the main() function
    # and also had incorrect logic for handling distrobox-init.
    # The correct place for this logic is inside handle_distrobox_init.
    # The original intent of this block was likely to handle the case where no arguments
    # are provided, or only 'distrobox-init' is provided without further arguments.
    # However, argparse with `required=True` for subparsers handles the latter.
    # We only need to handle the case where no arguments are provided at all.
    if len(sys.argv) == 1:
        parser.print_help(sys.stderr)
        sys.exit(1)

    args = parser.parse_args()

    sys.exit(args.func(args))


if __name__ == '__main__':
    main()
